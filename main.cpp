#include <iostream>
#ifdef __linux__
#include <SDL2/SDL.h>
#include <SDL2/SDL2_gfxPrimitives.h>
#include <SDL2/SDL_ttf.h>
#endif
#ifdef __APPLE__
#include <SDL.h>
#include <SDL2_gfxPrimitives.h>
#include <SDL_ttf.h>
#endif
#include <cmath>
#include "utils.h"
#include "rays.h"

#define FLCL_POINTERUP(surface) p = (Uint8*) (surface->pixels) + 3 * (src.y * TEXSIZE + src.x)
#define FLCL_DRAWCOLOR SDL_SetRenderDrawColor(renderer, *p*v, *(p+1)*v, *(p+2)*v, 0xff)

const float MAXDIST = hypot(MAPW, MAPH) * 0.9;
// 0 = empty; 4 bits to determine the texture of each face
Uint16 tiles[MAPW][MAPH] = {
	0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 0x0000, 0x0000, 0x0000, 0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 0x1234, 0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x0000, 0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 0x0000, 0x0000, 0x0000, 0x1234, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1234, 
	0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 0x1234, 
};
SDL_Texture* textures[15];
SDL_Surface* floortex;
SDL_Surface* ceiltex;
float fov = (M_PI / 2) / 2;

int filter(void* arg, SDL_Event* e) { return e->type == SDL_QUIT; }

int main(int argc, char* argv[])
{
	SDL_Window*   window;
	SDL_Renderer* renderer;
	if (init(&window, &renderer) || TTF_Init())
	{
		std::cout << SDL_GetError() << std::endl;
		return 1;
	}
	SDL_SetEventFilter(filter, NULL);
	if (loadtex(renderer, textures, floortex, ceiltex))
	{
		std::cout << SDL_GetError() << std::endl;
		return 1;
	}
	Vec2d<float> pos = { MAPW / 2.f, MAPH / 2.f, -1};
	float heading = 0;
	Vec2d<float> fieldleft, fieldright;
	TTF_Font* font = TTF_OpenFont("Sans.ttf", 12);
	if (!font) std::cout << SDL_GetError() << std::endl;
	SDL_Surface* text;
	SDL_Texture* texttex;
	char infostr[64];
	Uint32 lasttick = SDL_GetTicks();
	const Uint8* kb = SDL_GetKeyboardState(NULL);
	for (SDL_Event e; e.type != SDL_QUIT; SDL_PollEvent(&e))
	{
		float tdiff = (SDL_GetTicks() - lasttick);
		lasttick = SDL_GetTicks();
		// update player
		{
			float multiplier = (kb[SDL_SCANCODE_W] - kb[SDL_SCANCODE_S]) / 250.f;
			Vec2d<float> last = pos;
			pos.x += multiplier * tdiff * cos(heading);
			if (tiles[(int) pos.y][(int) pos.x]) pos.x = last.x;
			pos.y += multiplier * tdiff * sin(heading);
			if (tiles[(int) pos.y][(int) pos.x]) pos.y = last.y;
			heading += (kb[SDL_SCANCODE_D] - kb[SDL_SCANCODE_A]) * tdiff / 500.f;
			fieldleft  = { cos(heading - fov), sin(heading - fov), 1 };
			fieldright = { cos(heading + fov), sin(heading + fov), 1 };
		}
		// render
		// ceiling and floor
		{
		SDL_Point src, dest;
		Uint8* p;
		for (dest.y = HEIGHT / 2; dest.y < HEIGHT; dest.y++)
		{
			// distance to floor horizontally
			float dist = HEIGHT / (SQRT_2 * (dest.y - HEIGHT / 2));
			Vec2d<float> step = {
				dist / WIDTH * (fieldright.x - fieldleft.x),
				dist / WIDTH * (fieldright.y - fieldleft.y),
				-1
			};
			// get map coords
			Vec2d<float> mappos = {
				pos.x + dist * fieldleft.x,
				pos.y + dist * fieldleft.y,
				-1
			};
			float v = (0xff - 0xef * dist / MAXDIST) / 255.f;
			for (dest.x = 0; dest.x < WIDTH; dest.x++)
			{
				src.x = (int) ((mappos.x - (int) mappos.x) * TEXSIZE) & TEXSIZE - 1;
				src.y = (int) ((mappos.y - (int) mappos.y) * TEXSIZE) & TEXSIZE - 1;
				FLCL_POINTERUP(floortex); FLCL_DRAWCOLOR;
				SDL_RenderDrawPoint(renderer, dest.x, dest.y);
				FLCL_POINTERUP(ceiltex); FLCL_DRAWCOLOR;
				SDL_RenderDrawPoint(renderer, dest.x, HEIGHT - dest.y);

				mappos.x += step.x; mappos.y += step.y;
			}
		}
		}
		// walls
		{
			Vec2d<float> vel = fieldleft;
			Vec2d<float> step = {
				(fieldright.x - vel.x) / WIDTH,
				(fieldright.y - vel.y) / WIDTH,
				1
			};
			SDL_Rect src = { 0, 0, 1, TEXSIZE };
			for (int i = 0; i < WIDTH; i++)
			{
				vel.x += step.x; vel.y += step.y; MAG(vel);
				int side; Vec2d<int> tile;
				Vec2d<float> d = raycast(pos, vel, tiles, side, tile);
				d.mag *= cos(heading - atan2(vel.y, vel.x));
				float h = HEIGHT / d.mag;
				h *= (h >= 0);
				SDL_Rect r = { i, (int) ((HEIGHT - h) / 2), 1, (int) h };
				SDL_Texture* t = textures[
					(tiles[tile.y][tile.x] >> side * 4 & 0xf) - 1
				];
				Uint8 v = 0xff - 0xef * (d.mag / MAXDIST);
				SDL_SetTextureColorMod(t, v, v, v);
				src.x = ((side % 2) ? pos.x + d.x - tile.x : pos.y + d.y - tile.y) * TEXSIZE;
				SDL_RenderCopy(renderer, t, &src, &r);
			}
		}
		heading = fmod(heading, 2 * M_PI);
		heading += (heading < 0) * 2 * M_PI;
		sprintf(
			infostr,
			"%i deg | %4.1f fps",
			(int) (heading * 180 / M_PI),
			1000 / (float) tdiff
		);
		text = TTF_RenderText_Solid(font, infostr, (SDL_Color) { 255, 255, 255, 255 });
		texttex = SDL_CreateTextureFromSurface(renderer, text);
		SDL_Rect s = { 0, 0, text->w, text->h };
		SDL_RenderCopy(renderer, texttex, NULL, &s);
		SDL_FreeSurface(text);
		SDL_DestroyTexture(texttex);
		SDL_RenderPresent(renderer);
	}
	quit(textures, floortex, ceiltex, window, renderer);
	return 0;
}
